<!DOCTYPE html>
<html><head><meta charset="utf-8"><meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible"><meta content="width=device-width, initial-scale=1, maximum-scale=1" name="viewport"><meta content="Johannes Staffans" itemprop="author" name="author"><title>Johannes Staffans - Week 26</title><link href="https://fonts.googleapis.com/css?family=Merriweather:400,700|Open+Sans:400,700" rel="stylesheet"><link href="/styles/main.css" rel="stylesheet" type="text/css"></head><div><div class="header"><div class="header__content clearfix"><div class="sm-col sm-col-8"><div>personal website and blog of</div><h1 class="header__headline"><a href="/">Johannes Staffans</a></h1></div><div class="sm-col flex-column"><div><a href="/">posts</a><span> &middot; </span><a href="/pages/about.html">about</a></div><div class="pt1">elsewhere</div><div><a href="https://github.com/jstaffans">github</a><span> &middot; </span><a href="https://www.linkedin.com/in/jstaffans">linkedin</a><span> &middot; </span><a href="https://twitter.com/jstaffans">@jstaffans</a></div></div></div><div class="clearfix"><svg class="left border-triangle" version="1.1" xmlns="http://www.w3.org/2000/svg"><polygon class="mask" points="0,0 30,0 30,30 0,30"></polygon><polygon points="0,15 30,0 30,30"></polygon></svg><svg class="right border-triangle" version="1.1" xmlns="http://www.w3.org/2000/svg"><polygon class="mask" points="0,0 30,0 30,30 0,30"></polygon><polygon points="30,15 0,30 0,0"></polygon></svg></div></div><div class="container"><div><div class="flex items-baseline justify-between"><h2>Week 26</h2><div><span>30.06.2015</span></div></div><div><p>Some random things I've been thinking about this week:</p>
<h4><a href="#category-theory" id="category-theory"></a>Category Theory</h4>
<p>The first thing that comes into my mind when I hear "category theory" is the basic stuff we learned about at university, such as the set union operation. It turns out that category theory is much more than that — we can also reason about the functions and types that make up a software application using category theory. I don't really grasp it yet, but I will try to dive into it a bit more and maybe pick up some Haskell along the way.</p>
<ul>
<li>Bartosz Milewski has a really nice article series called <a href="http://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/">Category Theory for Programmers</a>.</li>
<li>For Clojure, there is the <a href="https://github.com/funcool/cats">cats library</a>.</li>
<li>I heard about a book called <a href="https://gumroad.com/l/maybe-haskell/?utm_source=giant-robots&amp;utm_medium=blog&amp;utm_campaign=announcement">Maybe Haskell</a> that should clear up some basic concepts.</li>
</ul>
<h4><a href="#n1-problem" id="n1-problem"></a>N+1 problem</h4>
<p>I recently had a scenario where an entity fetched from the database needed an additional field from a different storage backend, requiring an additional query to that storage medium for each row. Think of fetching a collection of books and for each book having to fetch its author separately. That's a lot of queries! This is called the N+1 problem.</p>
<p>In my case, I solved the problem with some application-layer caching. Another common pattern is to get the id's that need to be fetched and do a batch query using e.g. <code>IN (1, 2, 3 ..)</code>, which is one of the things that the neat <a href="https://github.com/kachayev/muse/blob/master/docs/sql.md">muse library for Clojure</a> provides. But keep in mind that using a list of id's is <a href="http://blog.jooq.org/2013/11/11/id-lists-arent-the-best-solution-for-the-n1-problem/">not going to perform very well</a> for a large number of id's.</p>
<h4><a href="#queues-back-pressure" id="queues-back-pressure"></a>Queues, back pressure</h4>
<p>I have grown very fond of queues as a way of decoupling the different parts of a system. <a href="https://www.youtube.com/watch?v=ROor6_NGIWU">The Language of the System</a> is one of those classic Rich Hickey talks and provides some context for why system communication is best done using data put on queues. Zach Tellman also did a <a href="https://www.youtube.com/watch?v=1bNOO3xxMc0">great talk on the challenges of a queue-based system</a> at Clojure/West 2015.</p>
<p>One of the terms that gets thrown around a lot when talking about queues is back pressure. This basically refers to some mechanism that the consumer of a queue has to let the producer know that it can't handle any more work at the moment and may come in the form of an HTTP response code, a RejectedExecutionException or something other interesting. Another strategy would be to eliminate the need for back pressure by using e.g. a dropping buffer.</p>
<h4><a href="#proper-api-design-and-hateoas" id="proper-api-design-and-hateoas"></a>Proper API design and HATEOAS</h4>
<p>I've finally gotten around the reading Leonard Richardson's and Mike Amundsen's book <a href="http://www.restfulwebapis.org/">RESTful Web APIs</a>. It's making me realise all the mistakes I've made designing APIs in the past — I'm definitely guilty of forcing API consumers to read the documentation instead of following the <a href="https://en.wikipedia.org/wiki/HATEOAS">HATEOAS pattern</a>.</p>
<p>It's also made me think again about the different data formats REST APIs normally produce. Everyone's favorite, JSON, turns out to be a pretty bad choice since it isn't a hypermedia format due to its lack of links. The <a href="https://github.com/cognitect/transit-format">Transit format</a> does and also takes advantage of the fast, native JSON parsing that browsers provide. Other extensions to JSON include <a href="http://stateless.co/hal_specification.html">HAL</a> and Collection+JSON.</p>
<p>Another observation would be that XML perhaps isn't so bad at all, since it can support the HATEOAS pattern bettern than JSON.</p>
</div><div><a href="/">Back</a></div></div></div><div class="footer"><p>&copy; 2015-2018 Johannes Staffans</p></div></div></html>