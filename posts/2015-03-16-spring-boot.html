<!DOCTYPE html>
<html><head><meta charset="utf-8"><meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible"><meta content="width=device-width, initial-scale=1, maximum-scale=1" name="viewport"><meta content="Johannes Staffans" itemprop="author" name="author"><title>Johannes Staffans - A vertical microservice with Spring Boot</title><link href="https://fonts.googleapis.com/css?family=Merriweather:400,700|Open+Sans:400,700" rel="stylesheet"><link href="/styles/main.css" rel="stylesheet" type="text/css"></head><div><div class="header"><div class="header__content clearfix"><div class="sm-col sm-col-8"><div>personal website and blog of</div><h1 class="header__headline"><a href="/">Johannes Staffans</a></h1></div><div class="sm-col flex-column"><div><a href="/">posts</a><span> &middot; </span><a href="/pages/about.html">about</a></div><div class="pt1">elsewhere</div><div><a href="https://github.com/jstaffans">github</a><span> &middot; </span><a href="https://www.linkedin.com/in/jstaffans">linkedin</a><span> &middot; </span><a href="https://twitter.com/jstaffans">@jstaffans</a></div></div></div><div class="clearfix"><svg class="left border-triangle" version="1.1" xmlns="http://www.w3.org/2000/svg"><polygon class="mask" points="0,0 30,0 30,30 0,30"></polygon><polygon points="0,15 30,0 30,30"></polygon></svg><svg class="right border-triangle" version="1.1" xmlns="http://www.w3.org/2000/svg"><polygon class="mask" points="0,0 30,0 30,30 0,30"></polygon><polygon points="30,15 0,30 0,0"></polygon></svg></div></div><div class="container"><div><div class="flex items-baseline justify-between"><h2>A vertical microservice with Spring Boot</h2><div><span>14.11.2017</span></div></div><div><p>At <a href="https://www.komoot.de">komoot</a>, we have lately been busy moving to a more microservice-oriented architecture. Many of our new features, such as the card feed that shows up whenever our mobile apps are opened, have been implemented in this fashion. We have also refactored and re-implemented some existing core components as dedicated services, one example being our routing engine.</p>
<p>The microservices we have are so far strictly backend-related — our web client is for example still a monolithic thing, albeit a much more modern one these days. Whenever we are implementing web-facing features we need to write code in two places: for the service containing the backend logic (probably in Java, Python or Clojure) and as part of the web UI, which is written in JavaScript using the <a href="http://facebook.github.io/react/">React.js library</a>.</p>
<p>The fact that you have to juggle two wildly different environments to do full-stack development can be a pain point. For features that require only simple UI elements React.js is also perhaps overkill — a few server-rendered pages or an iframe with a bit of jQuery can often be enough. I think having the ability to package the UI and the backend logic together as a truly stand-alone service is an attractive concept. This works especially well if the web-facing feature we want to implement is already conceptually separate from the rest of the web UI. Examples would be an import dialog, a feedback form, a payment processor and so on.</p>
<p>The cost of doing such "vertical microservices" is of course that you do not have as much flexibility, neither in the front- nor in the backend. You may e.g. have to bend Maven into doing things it was never really meant to do, such as optimizing JavaScript files. You also need to find a way of sharing stylesheets, so that the user gets a unified visual experience no matter which service is serving up the HTML (without having to copy and paste anything, of course).</p>
<h3><a href="#spring-boot" id="spring-boot"></a>Spring Boot</h3>
<p>In Java land, I have long been a fan of containerless web services à la Dropwizard. After playing around with Spring Boot for a while, I would say that it does an at least equally fine job. For a development team that's already used to Spring, there's also less of a learning curve and more familiar libraries that you can just pick up and start using, Spring Security being a good example.</p>
<h3><a href="#the-application" id="the-application"></a>The application</h3>
<p>A while ago I <a href="https://jstaffans.github.io/blog/2015/02/08/duct.html">developed a toy payment service while checking out Duct, a recent addition to the Clojure web application development ecosystem</a>. That application also morphed into a kind of "vertical microservice" as described above. I really enjoyed the seamless integration of Clojure and ClojureScript when developing that application, so I decided to see what it would be like to develop roughly the same application using Java and Spring Boot.</p>
<h4><a href="#backend" id="backend"></a>Backend</h4>
<p>When developing the Clojure-based payment application, I made good use of core.async for orchestration between different parts of the backend, such as the reporting subsystem and the payment processing component — the separation of behavior and data and event-based approach that core.async brings is a big win in my opinion. When looking for something similar for use in a Java project, I finally landed by <a href="https://github.com/ReactiveX/RxJava">RxJava</a>. The concept is not quite the same as core.async, but it does support a more functional, event-driven style of programming. It's also pretty easy to port some core.async goodies, such as implementing timeouts by waiting for the first of several Observables to emit a value (the core.async equivalent would be to wait for the first of several channels to close, where one channel is a timeout channel).</p>
<p>Some people may say that RxJava is best (or only) suited for UI programming, but I do think it has its place in the backend too. See <a href="http://techblog.netflix.com/2013/02/rxjava-netflix-api.html">this post on the Netflix blog</a> for a good example. The library does however come with a lot more concepts than a simple little thing like core.async, and I'm still only learning the basics.</p>
<h4><a href="#frontend" id="frontend"></a>Frontend</h4>
<p>The application relies on server-side rendering using Thymeleaf for its HTML, but there are still some frontend assets to take care of, namely stylesheets and Javascript files. When developing the frontend parts of a stand-alone microservice, there are basically two choices:</p>
<ol>
<li>
<p>Implement a separate, node.js-based build chain with for example Grunt for things like SASS compilation, JS minification and so forth. Then just serve the content as static files in your application and have Maven run an external task during the production build. This will be the favorite for most people with JS experience, I think.</p>
</li>
<li>
<p>Bend your existing Java build system to manage the frontend parts as well. Great for Java devs who don't want to learn about node.js! But good luck trying to get a web designer to install Maven if you need help with those stylesheets ...</p>
</li>
</ol>
<p>Since I am developing this project on my own and use Maven for Java development, I decided to go with the latter option. In order to not complicate things too much, I opted for a pretty basic but decently scalable setup:</p>
<ul>
<li>Dependencies to vendor libraries such as jQuery handled by <a href="http://www.webjars.org">Webjars</a>.</li>
<li>RequireJS for modularisation, with a <a href="https://github.com/bringking/requirejs-maven-plugin">Maven plugin</a> taking care of minification and concatenation of JavaScript files.</li>
<li>SASS stylesheets with a <a href="https://github.com/darrinholst/sass-java">filter</a> for development and, again, a <a href="https://github.com/darrinholst/sass-java/blob/master/sass-java-maven/README.md">Maven plugin</a> for building production CSS files.</li>
</ul>
<p>I would still like to implement cache busting for the frontend assets.</p>
<p>The hardest part of the entire project was easily getting everything frontend-related to behave as expected, both when running from the IDE and using a production JAR! I would not recommend going with the Maven-based approach for anything really complex. Still, I am pretty satisfied with the result and I hope the project can serve as an example of how to wire things up for a simple application.</p>
<h3><a href="#conclusion" id="conclusion"></a>Conclusion</h3>
<p>There are many avenues I didn't explore when creating this application — for the frontend parts, I could for example have relied on an asset pipeline like <a href="https://github.com/wro4j/wro4j">wro4j</a> or used a node.js build chain. I wanted to see how far you could get with simple building blocks such as small, focused Maven plugins, and it turns out it is definitely doable.</p>
<p>Java 8, Spring Boot and RxJava show that there is still some fun to be had in Java land — at least as far as the backend goes. But if you decide to go down the path of vertical microservices on the JVM, I think Clojure and ClojureScript is an unbeatable combination at the moment.</p>
<p><a href="https://github.com/jstaffans/pay-me-spring-boot">Check out the application on Github</a>!</p>
</div><div><a href="/">Back</a></div></div></div><div class="footer"><p>&copy; 2015-2017 Johannes Staffans</p></div></div></html>